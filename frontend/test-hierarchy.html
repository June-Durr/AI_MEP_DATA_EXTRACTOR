<!DOCTYPE html>
<html>
<head>
  <title>Hierarchy Test</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #f5f5f5; }
    .test { margin: 20px 0; padding: 15px; background: white; border-radius: 8px; }
    .pass { color: #28a745; font-weight: bold; }
    .fail { color: #dc3545; font-weight: bold; }
    .hierarchy { margin: 10px 0; padding-left: 20px; }
    .level0 { margin-left: 0px; }
    .level1 { margin-left: 20px; }
    .level2 { margin-left: 40px; }
    .level3 { margin-left: 60px; }
    pre { background: #f8f9fa; padding: 10px; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>üîå Electrical Hierarchy Detection Test</h1>

  <div class="test">
    <h2>Test Setup</h2>
    <p>Simulating equipment uploaded in RANDOM order:</p>
    <pre>1. Panel: 60A, 208V (smallest - uploaded first)
2. Transformer: 480V ‚Üí 208V
3. Panel: 100A, 208V (medium)
4. Panel: 225A, 208V (main - uploaded last)</pre>
  </div>

  <div class="test" id="results">
    <h2>Test Results</h2>
    <p>Testing hierarchy detection...</p>
  </div>

  <script>
    // Mock the hierarchy building function (simplified version)
    function buildElectricalHierarchy(panels, transformers) {
      const hierarchy = [];

      // Helper functions
      const parseVoltage = (voltageStr) => {
        if (!voltageStr || voltageStr === "Unknown") return 0;
        const matches = voltageStr.match(/\d+/g);
        if (!matches) return 0;
        return Math.max(...matches.map(n => parseInt(n)));
      };

      const normalizeVoltage = (voltageStr) => {
        return parseVoltage(voltageStr).toString();
      };

      const parseAmps = (ampStr) => {
        if (!ampStr || ampStr === "Unknown") return 0;
        const match = ampStr.match(/(\d+)/);
        return match ? parseInt(match[1]) : 0;
      };

      // Add transformers
      transformers.forEach(t => {
        hierarchy.push({
          type: "transformer",
          level: 0,
          voltage: parseVoltage(t.secondaryVoltage),
          voltageNormalized: normalizeVoltage(t.secondaryVoltage),
          amps: parseAmps(t.powerRating),
          data: t,
          parentId: null,
          children: []
        });
      });

      // Prepare panels
      const panelsWithMetadata = panels.map(p => ({
        panel: p,
        voltage: parseVoltage(p.voltage),
        voltageNormalized: normalizeVoltage(p.voltage),
        amps: parseAmps(p.busRating),
        hasMain: p.hasMain || false
      }));

      // Sort by voltage, then amperage (high to low)
      panelsWithMetadata.sort((a, b) => {
        if (a.voltage !== b.voltage) return b.voltage - a.voltage;
        if (a.amps !== b.amps) return b.amps - a.amps;
        if (a.hasMain !== b.hasMain) return a.hasMain ? -1 : 1;
        return 0;
      });

      // Build hierarchy
      panelsWithMetadata.forEach((panelMeta, index) => {
        const panel = panelMeta.panel;
        let parentId = null;
        let level = 0;
        let panelType = "branch";

        // RULE 1: Check for panel parent first (same voltage, higher amps)
        const potentialPanelParents = hierarchy.filter(
          item =>
            item.type !== "transformer" &&
            item.voltageNormalized === panelMeta.voltageNormalized &&
            item.amps > panelMeta.amps
        );

        if (potentialPanelParents.length > 0) {
          // Panel feeds this panel
          const parent = potentialPanelParents.reduce((closest, current) => {
            const closestDiff = Math.abs(closest.amps - panelMeta.amps);
            const currentDiff = Math.abs(current.amps - panelMeta.amps);
            return currentDiff < closestDiff ? current : closest;
          });

          parentId = parent.data.id;
          level = parent.level + 1;  // Increment!
          panelType = panelMeta.amps >= 200 ? "distribution" : "branch";
        } else {
          // RULE 2: Check for transformer match
          const matchingTransformer = hierarchy.find(
            item =>
              item.type === "transformer" &&
              item.voltageNormalized === panelMeta.voltageNormalized
          );

          if (matchingTransformer) {
            parentId = matchingTransformer.data.id;
            level = 1;

            if (matchingTransformer.children.length === 0 && panelMeta.hasMain) {
              panelType = "main";
            } else if (panelMeta.amps >= 200 || panelMeta.hasMain) {
              panelType = "distribution";
            }
          } else {
            level = transformers.length > 0 ? 1 : 0;
            if (panelMeta.amps >= 200 && panelMeta.hasMain) {
              panelType = "main";
            } else if (panelMeta.amps >= 200) {
              panelType = "distribution";
            }
          }
        }

        const equipmentNode = {
          type: panelType,
          level: level,
          voltage: panelMeta.voltage,
          voltageNormalized: panelMeta.voltageNormalized,
          amps: panelMeta.amps,
          data: panel,
          parentId: parentId,
          children: []
        };

        hierarchy.push(equipmentNode);

        if (parentId) {
          const parent = hierarchy.find(item => item.data.id === parentId);
          if (parent) {
            parent.children.push(panel.id);
          }
        }
      });

      return hierarchy;
    }

    // Run test
    function runTest() {
      const resultsDiv = document.getElementById('results');

      // Test data - RANDOM ORDER (as user uploads)
      const panels = [
        { id: 'p3', designation: 'P3', busRating: '60A', voltage: '208Y/120V', hasMain: false },  // Smallest first
        { id: 'p2', designation: 'P2', busRating: '100A', voltage: '208Y/120V', hasMain: false }, // Medium
        { id: 'p1', designation: 'P1', busRating: '225A', voltage: '208Y/120V', hasMain: true }   // Main last
      ];

      const transformers = [
        { id: 't1', designation: 'T1', primaryVoltage: '480V', secondaryVoltage: '208Y/120V', powerRating: '75 kVA' }
      ];

      const hierarchy = buildElectricalHierarchy(panels, transformers);

      console.log('Hierarchy:', hierarchy);

      // Display results
      let html = '<h3>Expected Hierarchy:</h3>';
      html += '<div class="hierarchy">';
      html += '<div class="level0">Level 0: Transformer T1 (480V ‚Üí 208V)</div>';
      html += '<div class="level1">‚îú‚îÄ Level 1: Panel P1 (225A, 208V) - MAIN</div>';
      html += '<div class="level2">‚îÇ  ‚îú‚îÄ Level 2: Panel P2 (100A, 208V) - Distribution</div>';
      html += '<div class="level3">‚îÇ  ‚îÇ  ‚îî‚îÄ Level 3: Panel P3 (60A, 208V) - Branch</div>';
      html += '</div>';

      html += '<h3>Actual Hierarchy:</h3>';
      html += '<div class="hierarchy">';

      hierarchy.forEach(item => {
        const indent = item.level;
        const className = `level${indent}`;
        const parent = item.parentId ? hierarchy.find(h => h.data.id === item.parentId) : null;
        const parentName = parent ? parent.data.designation : 'None';

        html += `<div class="${className}">`;
        if (item.type === 'transformer') {
          html += `Level ${item.level}: Transformer ${item.data.designation} (${item.data.primaryVoltage} ‚Üí ${item.data.secondaryVoltage})`;
        } else {
          html += `Level ${item.level}: Panel ${item.data.designation} (${item.amps}A, ${item.voltage}V) - ${item.type.toUpperCase()} [Parent: ${parentName}]`;
        }
        html += '</div>';
      });
      html += '</div>';

      // Verify test results
      html += '<h3>Test Assertions:</h3>';
      const tests = [
        { name: 'Transformer is Level 0', pass: hierarchy.find(h => h.type === 'transformer')?.level === 0 },
        { name: 'Main Panel (225A) is Level 1', pass: hierarchy.find(h => h.amps === 225)?.level === 1 },
        { name: 'Distribution Panel (100A) is Level 2', pass: hierarchy.find(h => h.amps === 100)?.level === 2 },
        { name: 'Branch Panel (60A) is Level 3', pass: hierarchy.find(h => h.amps === 60)?.level === 3 },
        { name: '225A panel parent is Transformer', pass: hierarchy.find(h => h.amps === 225)?.parentId === 't1' },
        { name: '100A panel parent is 225A panel', pass: hierarchy.find(h => h.amps === 100)?.parentId === 'p1' },
        { name: '60A panel parent is 100A panel', pass: hierarchy.find(h => h.amps === 60)?.parentId === 'p2' }
      ];

      tests.forEach(test => {
        const status = test.pass ? '<span class="pass">‚úì PASS</span>' : '<span class="fail">‚úó FAIL</span>';
        html += `<div>${status} - ${test.name}</div>`;
      });

      const allPass = tests.every(t => t.pass);
      html += `<h3>${allPass ? '<span class="pass">‚úÖ ALL TESTS PASSED</span>' : '<span class="fail">‚ùå SOME TESTS FAILED</span>'}</h3>`;

      resultsDiv.innerHTML = html;
    }

    runTest();
  </script>
</body>
</html>
